## 一、段式存储管理

### 1、分段

**进程的地址空间**：按照程序**自身的逻辑**关系**划分为若干个段**，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址。

**内存分配规则：**以段为单位进行分配，**每个段在内存中占连续空间**，但**各段之间可以不相邻**。

![img](https://img-blog.csdnimg.cn/img_convert/dd4c3e0ea422a413bee9db884a545772.png)

 分段系统的[逻辑地址](https://so.csdn.net/so/search?q=逻辑地址&spm=1001.2101.3001.7020)结构由**段号（段名）**和**段内地址（段内偏移量）**所组成。

![img](https://img-blog.csdnimg.cn/img_convert/149cc38836ba917c8e00cd52e55055fd.png)

### 2、段表

![img](https://img-blog.csdnimg.cn/img_convert/7cf5c86589aec972f77089f6d0a6d069.png)

每一个程序设置一个段表，放在内存,属于进程的现场信息
 

### 3、地址变换

![img](https://img-blog.csdnimg.cn/img_convert/066b1ac3aa36bbb0d9811e7dc622de7d.png)



![img](https://img-blog.csdnimg.cn/img_convert/55dc8c61a0d420e807df269f131921d7.png)

### 4、段的保护

**越界中断处理**
   进程在执行过程中，有时需要扩大分段，如数据段。由于要访问的地址超出原有的段长，所以发越界中断。操作系统处理中断时 ，首先判断该段的“扩充位”，如可扩充，则增加段的长度；否则按出错处理

**缺段中断处理**

检查内存中是否有足够的空闲空间
  ①若有，则装入该段，修改有关数据结构，中断返回
  ②若没有，检查内存中空闲区的总和是否满足要求，是则应采用紧缩技术，转 ① ；否则，淘汰一（些）段，转①

### 5、段的动态连接

为何要进行段的[动态链接](https://so.csdn.net/so/search?q=动态链接&spm=1001.2101.3001.7020)？
大型程序由若干程序段，若干数据段组成
进程的某些程序段在进程运行期间可能根本不用
互斥执行的程序段没有必要同时驻留内存
有些程序段执行一次后不再用到
静态链接花费时间，浪费空间

在一个程序运行开始时，只将主程序段装配好并调入主存。其它各段的装配是在主程序段运行过程中逐步进行的。每当需要调用一个新段时，再将这个新段装配好，并与主程序段连接。
页式存储管理：难以完成动态链接，其逻辑地址是一维的



### 6、信息的保护与共享

这里主要与页式存储管理进行一下对比。

**分段比分页更容易实现信息的共享和保护。**

![img](https://img-blog.csdnimg.cn/img_convert/88fb1213268be79e9ee256abffe28bfa.png)



 纯代码举例：比如，有一个代码段只是简单的输出“Hello World!”。

![img](https://img-blog.csdnimg.cn/img_convert/4492dcf8633a0b124508de398b7ff46b.png)

### 7、页式系统与段式系统的对比

### 分页思想 [深入解析分段与分页 - Happysnaker - 博客园](https://www.cnblogs.com/happysnaker/p/15264905.html#分页式管理)

对于分段式的管理，一段时间后主存上将会遍布大大小小的外部碎片，操作系统难以进行维护，分段的思想是将内存空间分割成不同长度的分片，由于长度不是固定的，产生外部碎片是必然的，之前提到的将整个程序一起装入的方法虽然不会产生外部碎片，但会产生巨大的内部碎片，我们需要更细粒度的划分，以减少内部碎片的产生，解决这一问题的办法是将空间分割成较小的、固定长度的分片，这就是分页式管理。

![img](https://img-blog.csdnimg.cn/img_convert/27b26a8002a6a7e0393f684187449f0e.png)

补充：

段长是可变的，页的大小是固定的。

分段存储：段内地址W字段溢出将产生越界中断。

分页存储：段内地址W字段溢出会自动加入到页号中。

### 8、总结

![img](https://img-blog.csdnimg.cn/img_convert/e51ae51085e88c9bcdd09d2fb0794161.png)



## 二、段页式存储管理

### 1、分页、分段的有缺点分析

![img](https://img-blog.csdnimg.cn/img_convert/fd3d381ca075e346ba42a622515ee418.png)




段页存储不会产生外部碎片，因位先分段，再分页，分页后就离散化了，每个页可以分在内存的任何一个页，这个段页就成了逻辑上的概念，实质上变成了分页的管理，所以按照分页来看，是没有外部碎片的。那些理解成在一个段内再分页的同鞋，你们理解错啦！比如A页和B页逻辑上是在1号段里面，但是分页后，A页可以存在内存的任何地方B页也是，在实际的内存存放这两个页的时候，并不是先在内存化出一个段的长度出来，然后在段内分页的！

### 2、基本思想

用户程序划分：按段式划分（对用户来讲，按段的逻辑关系进行划分；对系统讲，按页划分每一段）

逻辑地址：

![img](https://img-blog.csdnimg.cn/img_convert/8f86961a988b0b1deb5019eab9605b4c.png)

 **内存划分：按页式存储管理方案**
 **内存分配：以页为单位进行分配**

![img](https://img-blog.csdnimg.cn/img_convert/14b5461dd6ef49725d42bc70725a5e23.png)



### 3、逻辑地址结构

![img](https://img-blog.csdnimg.cn/img_convert/2dac3bdeb1ae863198296d078d150d5e.png)



### 4、段表页表

![img](https://img-blog.csdnimg.cn/img_convert/8cd4447180a66b429567c8f07ef3b2c0.png)

### 5、地址转换

![img](https://img-blog.csdnimg.cn/img_convert/b19fbf879235a1ad5674b553536baecf.png)

### 6、评价

**优点：**
保留了分段和请求分页存储管理的全部优点
提供了虚存空间，能更有效利用主存

**缺点：**
增加了硬件成本
系统复杂度较大
 

### 7、总结

![img](https://img-blog.csdnimg.cn/img_convert/a37ab19f48c5a7658b864500ebb328e1.png)****